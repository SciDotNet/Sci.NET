<#@ template language="C#" #>
<#@ import namespace="System.Reflection.Emit" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Reflection" #>
<#@ output extension=".cs" #>
<#
#nullable enable
            var oneByteOpCodeNames = new string?[0x120];
            var twoByteOpCodeNames = new string?[0x30];
            var oneByteOpcodes = new OpCode[0x120];
            var twoByteOpcodes = new OpCode[0x30];
            var fields = typeof(OpCodes).GetFields(BindingFlags.Public | BindingFlags.Static);
            var opCodeKvp = new Dictionary<string, ushort>();

            foreach (var field in fields)
            {
                var opCode = (OpCode)field.GetValue(null);

                if (opCode.Size == 1)
                {
                    oneByteOpCodeNames[(ushort)opCode.Value] = field.Name;
                    oneByteOpcodes[(ushort)opCode.Value] = opCode;
                    opCodeKvp.Add(field.Name, (ushort)opCode.Value);
                }
                else if (opCode.Size == 2)
                {
                    var shiftedValue = (byte)(ushort)opCode.Value & 0xFF;
                    twoByteOpCodeNames[shiftedValue] = field.Name;
                    twoByteOpcodes[shiftedValue] = opCode;
                    opCodeKvp.Add(field.Name, (ushort)opCode.Value);
                }
            }

            for (var i = 0; i < 0x120; i++)
            {
                if (oneByteOpCodeNames[i] is null)
                {
                    oneByteOpCodeNames[i] = nameof(OpCodes.Nop);
                    oneByteOpcodes[i] = OpCodes.Nop;
                }
            }

            for (var i = 0; i < 0x30; i++)
            {
                if (twoByteOpCodeNames[i] is null)
                {
                    twoByteOpCodeNames[i] = nameof(OpCodes.Nop);
                    twoByteOpcodes[i] = OpCodes.Nop;
                }
            }
#>
// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.

using System.Reflection.Emit;
using System.CodeDom.Compiler;

namespace Sci.NET.Accelerators.Disassembly;

// ReSharper disable ArrangeTrailingCommaInMultilineLists
#pragma warning disable RCS1035

/// <summary>
/// Provides a list of IL instructions.
/// </summary>
[PublicAPI, GeneratedCode("TextTemplatingFileGenerator", "2.x")]
public static class IlInstructionProvider
{
    private static readonly OpCode[] OneByteOpCodes = new OpCode[]
    {
<#
            foreach (var opCode in oneByteOpCodeNames)
            {
#>
        OpCodes.<#= opCode #>,
<#
            }
#>
    };

    private static readonly OpCode[] TwoByteOpCodes = new OpCode[]
    {
<#
            foreach (var opCode in twoByteOpCodeNames)
            {
#>
        OpCodes.<#= opCode #>,
<#
            }
#>
    };

    /// <summary>
    /// Gets the opcode for the given value.
    /// </summary>
    /// <param name="opCode">The opcode value.</param>
    /// <returns>The opcode.</returns>
    public static OpCode GetOneByteOpCode(int opCode)
    {
        return OneByteOpCodes.Length > opCode ? OneByteOpCodes[opCode] : default;
    }

    /// <summary>
    /// Gets the opcode for the given value.
    /// </summary>
    /// <param name="opCode">The opcode value.</param>
    /// <returns>The opcode.</returns>
    public static OpCode GetTwoByteOpCode(int opCode)
    {
        return TwoByteOpCodes.Length > opCode ? TwoByteOpCodes[opCode] : default;
    }
}

// ReSharper disable InconsistentNaming
#pragma warning disable CA1028, CS1591, SA1602, CA1707

/// <summary>
/// Enumerates the IL instruction types.
/// </summary>
[PublicAPI, GeneratedCode("TextTemplatingFileGenerator", "2.x")]
public enum OpCodeTypes : ushort
{
<#
            foreach (var opCode in opCodeKvp)
            {
#>
    <#= opCode.Key #> = 0x<#= opCode.Value.ToString("x4") #>,
<#
            }
#>
}

/// <summary>
/// Provides extension methods for <see cref="OpCodeTypes"/>.
/// </summary>
[PublicAPI, GeneratedCode("TextTemplatingFileGenerator", "2.x")]
public static class OpCodeTypeExtensions
{
    /// <summary>
    /// Gets the <see cref="OpCodeTypes"/> for the given <see cref="OpCode"/>.
    /// </summary>
    public static OpCodeTypes Type(this OpCode opCode)
    {
        return (OpCodeTypes)opCode.Value;
    }
}

#pragma warning restore CS1591, CA1028, SA1602, RCS1035
// <auto-generated />
// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.

using Sci.NET.Mathematics.Tensors;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Differentiation;

public class ActivationFunctionsBackwardsTests : IntegrationTestBase
{
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Sigmoid_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Sigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.196611933241482 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.731058578630005 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Tanh_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Tanh();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.419974341614026 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.761594155955765 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReLU_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.ReLU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReLU_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.ReLU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReLU_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.ReLU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void LeakyReLU_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.LeakyReLU(0.01);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void LeakyReLU_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.LeakyReLU(0.01);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.01 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.01 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void LeakyReLU_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.LeakyReLU(0.01);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.01 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Softmax_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Softmax();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Softmax_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 2 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Softmax();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Elu_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Elu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Elu_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Elu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.367879441171442 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.632120558828558 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Elu_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Elu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Celu_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Celu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Celu_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Celu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.367879441171442 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.632120558828558 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Celu_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Celu(1.0);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Swish_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Swish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.927670511871487 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.731058578630005 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Swish_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Swish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.0723294881285133 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.268941421369995 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Swish_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Swish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Mish_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Mish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.04903622009979 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.86509838826731 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Mish_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Mish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.0592167558773949 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.303401461374109 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Mish_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Mish();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.6 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardTanh_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardTanh(-1.0d, 1.0d);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardTanh_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0.5 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardTanh(-1.0d, 1.0d);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardTanh_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardTanh(-1.0d, 1.0d);

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardSigmoid_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardSigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardSigmoid_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardSigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void HardSigmoid_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0.5 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.HardSigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.25 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void LogSigmoid_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.LogSigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.268941421369995 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.313261687518223 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void LogSigmoid_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.LogSigmoid();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.731058578630005 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -1.31326168751822 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftPlus_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftPlus();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.731058578630005 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1.31326168751822 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftPlus_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftPlus();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.268941421369995 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.313261687518223 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftPlus_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftPlus();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.693147180559945 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftSign_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftSign();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.25 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftSign_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftSign();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.25 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.5 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void SoftSign_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.SoftSign();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void GELU_Example_1_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.GELU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.08508644753214 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.841191990608276 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void GELU_Example_2_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { -1 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.GELU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { -0.0850864475321375 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { -0.158808009391723 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void GELU_Example_3_Backwards(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 0 }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.GELU();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0 }, 1e-9);
    }

}
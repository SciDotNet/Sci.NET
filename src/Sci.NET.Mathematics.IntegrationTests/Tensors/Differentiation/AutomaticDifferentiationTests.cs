// <auto-generated />
// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.

using Sci.NET.Mathematics.Tensors;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Differentiation;

public class AutomaticDifferentiationTests : IntegrationTestBase
{
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Sin_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Sin();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5403023058681398 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.8414709848078965 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Cos_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Cos();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { -0.8414709848078965 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.5403023058681398 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Tan_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Tan();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 3.425518820814759 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1.5574077246549023 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Sin2_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Sin2();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 0.9092974268256818 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.7080734182735712 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Cos2_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Cos2();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { -0.9092974268256818 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 0.2919265817264289 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Tan2_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Tan2();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 10.669858944975315 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 2.42551882081476 }, 1e-9);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_Sinh_1(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { 1.0d }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.Sinh();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.5430806348152437 }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { 1.1752011936438014 }, 1e-9);
    }

}
<#@ template language="C#" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
    var functions = new List<(string FunctionName, string TestName, string Input, string Primal, string Derivative)>
    {
        ("Sin", "Sin_1", "1.0d", "0.8414709848078965", "0.5403023058681398"),
        ("Cos", "Cos_1", "1.0d", "0.5403023058681398", "-0.8414709848078965"),
        ("Tan", "Tan_1", "1.0d", "1.5574077246549023", "3.425518820814759"),
        ("Sin2", "Sin2_1", "1.0d", "0.7080734182735712", "0.9092974268256818"),
        ("Cos2", "Cos2_1", "1.0d", "0.2919265817264289", "-0.9092974268256818"),
        ("Tan2", "Tan2_1", "1.0d", "2.42551882081476", "10.669858944975315"),
        ("Sinh", "Sinh_1", "1.0d", "1.1752011936438014", "1.5430806348152437"),
        ("Cosh", "Cosh_1", "1.0d", "1.5430806348152437", "1.1752011936438014"),
        ("Tanh", "Tanh_1", "1.0d", "0.7615941559557649", "0.41997434161402614")
    };
#>
// <auto-generated />
// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.

using Sci.NET.Mathematics.Tensors;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Differentiation;

public class TrigonometryBackwardsTests : IntegrationTestBase
{
<#
    foreach (var function in functions)
    {
#>
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void Backwards_<#= function.TestName #>(IDevice device)
    {
        // Arrange
        using var tensor = Tensor.FromArray<double>(new double[] { <#=function.Input #> }, requiresGradient: true);
        tensor.To(device);
        var result = tensor.<#= function.FunctionName #>();

        // Act
        result.Backward();

        // Assert
        tensor.Gradient!.Should().NotBeNull();
        result.Gradient!.Should().NotBeNull();

        tensor.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { <#= function.Derivative #> }, 1e-9);
        result.Gradient!.Should().HaveApproximatelyEquivalentElements(new double[] { 1.0d }, 1e-9);
        result.Should().HaveApproximatelyEquivalentElements(new double[] { <#= function.Primal #> }, 1e-9);
    }

<#
}
#>
}
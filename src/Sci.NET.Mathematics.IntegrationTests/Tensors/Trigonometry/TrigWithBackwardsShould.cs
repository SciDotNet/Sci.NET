// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.
// <auto-generated />

using System.Numerics;
using Sci.NET.Common.Numerics;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Mathematics.Tensors;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Trigonometry;

public class TrigWithBackwardsShould : IntegrationTestBase
{
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSin(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.909297426825682, -0.841470984807897, 0, 0.841470984807897, 0.909297426825682 };
        var expectedGradient = new[] { -0.416146836547142, 0.54030230586814, 1, 0.54030230586814, -0.416146836547142 };
        input.To(device);

        // Act
        var result = input.Sin();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCos(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.416146836547142, 0.54030230586814, 1, 0.54030230586814, -0.416146836547142 };
        var expectedGradient = new[] { 0.909297426825682, 0.841470984807897, 0, -0.841470984807897, -0.909297426825682 };
        input.To(device);

        // Act
        var result = input.Cos();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTan(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 2.18503986326152, -1.5574077246549, 0, 1.5574077246549, -2.18503986326152 };
        var expectedGradient = new[] { 5.77439920404192, 3.42551882081476, 1, 3.42551882081476, 5.77439920404192 };
        input.To(device);

        // Act
        var result = input.Tan();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSin2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.826821810431806, 0.708073418273571, 0, 0.708073418273571, 0.826821810431806 };
        var expectedGradient = new[] { 0.756802495307928, -0.909297426825682, 0, 0.909297426825682, -0.756802495307928 };
        input.To(device);

        // Act
        var result = input.Sin2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCos2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.173178189568194, 0.291926581726429, 1, 0.291926581726429, 0.173178189568194 };
        var expectedGradient = new[] { -0.756802495307928, 0.909297426825682, 0, -0.909297426825682, 0.756802495307928 };
        input.To(device);

        // Act
        var result = input.Cos2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTan2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 4.77439920404192, 2.42551882081476, 0, 2.42551882081476, 4.77439920404192 };
        var expectedGradient = new[] { 25.2345848944344, -10.6698589449753, 0, 10.6698589449753, -25.2345848944344 };
        input.To(device);

        // Act
        var result = input.Tan2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSinh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -3.62686040784702, -1.1752011936438, 0, 1.1752011936438, 3.62686040784702 };
        var expectedGradient = new[] { 3.76219569108363, 1.54308063481524, 1, 1.54308063481524, 3.76219569108363 };
        input.To(device);

        // Act
        var result = input.Sinh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCosh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 3.76219569108363, 1.54308063481524, 1, 1.54308063481524, 3.76219569108363 };
        var expectedGradient = new[] { -3.62686040784702, -1.1752011936438, 0, 1.1752011936438, 3.62686040784702 };
        input.To(device);

        // Act
        var result = input.Cosh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTanh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.964027580075817, -0.761594155955765, 0, 0.761594155955765, 0.964027580075817 };
        var expectedGradient = new[] { 0.0706508248531645, 0.419974341614026, 1, 0.419974341614026, 0.0706508248531645 };
        input.To(device);

        // Act
        var result = input.Tanh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSinh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 13.1541164180082, 1.38109784554182, 0, 1.38109784554182, 13.1541164180082 };
        var expectedGradient = new[] { -27.2899171971278, -3.62686040784702, 0, 3.62686040784702, 27.2899171971278 };
        input.To(device);

        // Act
        var result = input.Sinh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCosh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 14.1541164180082, 2.38109784554182, 1, 2.38109784554182, 14.1541164180082 };
        var expectedGradient = new[] { -27.2899171971278, -3.62686040784702, 0, 3.62686040784702, 27.2899171971278 };
        input.To(device);

        // Act
        var result = input.Cosh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTanh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.929349175146836, 0.580025658385974, 0, 0.580025658385974, 0.929349175146836 };
        var expectedGradient = new[] { -0.136218687427113, -0.639700008449224, 0, 0.639700008449224, 0.136218687427113 };
        input.To(device);

        // Act
        var result = input.Tanh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASin(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -1.0, -0.5, 0.0, 0.5, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { -1.5707963267949, -0.523598775598299, 0, 0.523598775598299, 1.5707963267949 };
        var expectedGradient = new[] { double.PositiveInfinity, 1.15470053837925, 1, 1.15470053837925, double.PositiveInfinity };
        input.To(device);

        // Act
        var result = input.ASin();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACos(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -1.0, -0.5, 0.0, 0.5, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { 3.14159265358979, 2.09439510239319, 1.5707963267948966, 1.0471975511965979, 0 };
        var expectedGradient = new[] { double.NegativeInfinity, -1.1547005383792517, -1, -1.1547005383792517, double.NegativeInfinity };
        input.To(device);

        // Act
        var result = input.ACos();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATan(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -1.10714871779409, -0.785398163397448, 0, 0.785398163397448, 1.10714871779409 };
        var expectedGradient = new[] { 0.2, 0.5, 1, 0.5, 0.2 };
        input.To(device);

        // Act
        var result = input.ATan();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASin2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -1.0, -0.5, 0.0, 0.5, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { 2.46740110027234, 0.274155677808038, 0, 0.274155677808038, 2.46740110027234 };
        var expectedGradient = new[] { double.NegativeInfinity, -1.20919957615615, 0, 1.20919957615615, double.PositiveInfinity };
        input.To(device);

        // Act
        var result = input.ASin2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACos2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -1.0, -0.5, 0.0, 0.5, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { 9.86960440108936, 4.3864908449286, 2.46740110027234, 1.09662271123215, 0 };
        var expectedGradient = new[] { double.NegativeInfinity, -4.83679830462458, -3.14159265358979, -2.41839915231229, double.NaN };
        input.To(device);

        // Act
        var result = input.ACos2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATan2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 1.2257782833131, 0.616850275068085, 0, 0.616850275068085, 1.2257782833131 };
        var expectedGradient = new[] { -0.442859487117636, -0.785398163397448, 0, 0.785398163397448, 0.442859487117636 };
        input.To(device);

        // Act
        var result = input.ATan2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASinh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -1.44363547517881, -0.881373587019543, 0, 0.881373587019543, 1.44363547517881 };
        var expectedGradient = new[] { 0.447213595499958, 0.707106781186548, 1, 0.707106781186548, 0.447213595499958 };
        input.To(device);

        // Act
        var result = input.ASinh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACosh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 1.0, 2.0, 3.0, 4.0, 5.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.31695789692482, 1.76274717403909, 2.06343706889556, 2.29243166956118 };
        var expectedGradient = new[] { double.PositiveInfinity, 0.577350269189626, 0.353553390593274, 0.258198889747161, 0.204124145231932 };
        input.To(device);

        // Act
        var result = input.ACosh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATanh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -0.9, -0.5, 0.0, 0.5, 0.9 }, requiresGradient: true);
        var expectedOutput = new[] { -1.47221948958322, -0.549306144334055, 0, 0.549306144334055, 1.47221948958322 };
        var expectedGradient = new[] { 5.26315789473684, 1.33333333333333, 1, 1.33333333333333, 5.26315789473684 };
        input.To(device);

        // Act
        var result = input.ATanh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASinh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 2.08408338519475, 0.776819399895696, 0, 0.776819399895696, 2.08408338519475 };
        var expectedGradient = new[] { -1.29122682289201, -1.24645048028046, 0, 1.24645048028046, 1.29122682289201 };
        input.To(device);

        // Act
        var result = input.ASinh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACosh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 1.0, 2.0, 3.0, 4.0, 5.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.73437810227264, 3.10727759958278, 4.2577725372923, 5.25524295960705 };
        var expectedGradient = new[] { double.NaN, 1.52069199260189, 1.24645048028046, 1.06555432050394, 0.93588131010357 };
        input.To(device);

        // Act
        var result = input.ACosh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATanh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -0.9, -0.5, 0.0, 0.5, 0.9 }, requiresGradient: true);
        var expectedOutput = new[] { 2.16743022550868, 0.301737240203146, 0, 0.301737240203146, 2.16743022550868 };
        var expectedGradient = new[] { -15.4970472587707, -1.46481638489081, 0, 1.46481638489081, 15.4970472587707 };
        input.To(device);

        // Act
        var result = input.ATanh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsc(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 2, 1.15470053837925, 1.15470053837925, 1.4142135623731, 2 };
        var expectedGradient = new[] { -3.46410161513775, -0.666666666666667, 0.666666666666667, 1.4142135623731, 3.46410161513775 };
        input.To(device);

        // Act
        var result = input.Csc();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSec(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 1.15470053837925, 2, -2, -1.4142135623731, -1.15470053837925 };
        var expectedGradient = new[] { 0.666666666666667, 3.46410161513775, 3.46410161513775, 1.4142135623731, 0.666666666666667 };
        input.To(device);

        // Act
        var result = input.Sec();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCot(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 1.73205080756888, 0.577350269189626, -0.577350269189626, -1, -1.73205080756888 };
        var expectedGradient = new[] { -4, -1.33333333333333, -1.33333333333333, -2, -4 };
        input.To(device);

        // Act
        var result = input.Cot();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsc2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 4, 1.33333333333333, 1.33333333333333, 2, 4 };
        var expectedGradient = new[] { -13.856406460551, -1.539600717839, 1.539600717839, 4, 13.856406460551 };
        input.To(device);

        // Act
        var result = input.Csc2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSec2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 1.33333333333333, 4, 4, 2, 1.33333333333333 };
        var expectedGradient = new[] { 1.539600717839, 13.856406460551, -13.856406460551, -4, -1.539600717839 };
        input.To(device);

        // Act
        var result = input.Sec2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCot2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.523598775598299, 1.04719755119660, 2.09439510239320, 2.35619449019234, 2.61799387799149 }, requiresGradient: true);
        var expectedOutput = new[] { 3, 0.333333333333333, 0.333333333333333, 1, 3 };
        var expectedGradient = new[] { -13.856406460551, -1.539600717839, 1.539600717839, 4, 13.856406460551 };
        input.To(device);

        // Act
        var result = input.Cot2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsch(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.275720564771783, -0.850918128239322, double.PositiveInfinity, 0.850918128239322, 0.275720564771783 };
        var expectedGradient = new[] { -0.286009000645084, -1.11728552744927, double.NegativeInfinity, -1.11728552744927, -0.286009000645084 };
        input.To(device);

        // Act
        var result = input.Csch();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSech(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.26580222883408, 0.648054273663885, 1, 0.648054273663885, 0.26580222883408 };
        var expectedGradient = new[] { 0.256240679441676, 0.493554347564573, 0, -0.493554347564573, -0.256240679441676 };
        input.To(device);

        // Act
        var result = input.Sech();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCoth(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -1.03731472072755, -1.31303528549933, double.PositiveInfinity, 1.31303528549933, 1.03731472072755 };
        var expectedGradient = new[] { -0.0760218298380711, -0.72406166096631, double.NegativeInfinity, -0.72406166096631, -0.0760218298380711 };
        input.To(device);

        // Act
        var result = input.Coth();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsch2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.0760218298380711, 0.72406166096631, double.PositiveInfinity, 0.72406166096631, 0.0760218298380711 };
        var expectedGradient = new[] { 0.157717126375352, 1.90143701945204, double.NegativeInfinity, -1.90143701945204, -0.157717126375352 };
        input.To(device);

        // Act
        var result = input.Csch2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSech2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.0706508248531645, 0.419974341614026, 1, 0.419974341614026, 0.0706508248531645 };
        var expectedGradient = new[] { 0.136218687427113, 0.639700008449224, 0, -0.639700008449224, -0.136218687427113 };
        input.To(device);

        // Act
        var result = input.Sech2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCoth2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 1.07602182983807, 1.72406166096631, double.PositiveInfinity, 1.72406166096631, 1.07602182983807 };
        var expectedGradient = new[] { 0.157717126375352, 1.90143701945204, double.NegativeInfinity, -1.90143701945204, -0.157717126375352 };
        input.To(device);

        // Act
        var result = input.Coth2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsc(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.523598775598299, -1.5707963267949, 1.5707963267949, 0.523598775598299, 0.339836909454122 };
        var expectedGradient = new[] { -0.288675134594813, double.NegativeInfinity, double.NegativeInfinity, -0.288675134594813, -0.117851130197758 };
        input.To(device);

        // Act
        var result = input.ACsc();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASec(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { 2.0943951023932, 3.14159265358979, 0, 1.0471975511966, 1.23095941734077 };
        var expectedGradient = new[] { 0.288675134594813, double.PositiveInfinity, double.PositiveInfinity, 0.288675134594813, 0.117851130197758 };
        input.To(device);

        // Act
        var result = input.ASec();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACot(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.463647609000806, -0.785398163397448, 1.5707963267949, 0.785398163397448, 0.463647609000806 };
        var expectedGradient = new[] { -0.2, -0.5, -1, -0.5, -0.2 };
        input.To(device);

        // Act
        var result = input.ACot();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsc2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.274155677808038, 2.46740110027234, 2.46740110027234, 0.274155677808038, 0.115489125027329 };
        var expectedGradient = new[] { 0.302299894039036, double.PositiveInfinity, double.NegativeInfinity, -0.302299894039036, -0.0801003277241628 };
        input.To(device);

        // Act
        var result = input.ACsc2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASec2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { 4.3864908449286, 9.86960440108936, 0, 1.09662271123215, 1.51526108713994 };
        var expectedGradient = new[] { 1.20919957615615, double.PositiveInfinity, double.NaN, 0.604599788078073, 0.290139917122368 };
        input.To(device);

        // Act
        var result = input.ASec2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACot2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 0.0, 1.0, 2.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.214969105332164, 0.616850275068085, 2.46740110027234, 0.616850275068085, 0.214969105332164 };
        var expectedGradient = new[] { 0.185459043600322, 0.785398163397448, -3.14159265358979, -0.785398163397448, -0.185459043600322 };
        input.To(device);

        // Act
        var result = input.ACot2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsch(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.481211825059603, -0.881373587019543, 0.881373587019543, 0.481211825059603, 0.327450150237258 };
        var expectedGradient = new[] { -0.223606797749979, -0.707106781186548, -0.707106781186548, -0.223606797749979, -0.105409255338946 };
        input.To(device);

        // Act
        var result = input.ACsch();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASech(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.2, 0.3, 0.5, 0.8, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { 2.29243166956118, 1.87382024252741, 1.31695789692482, 0.693147180559945, 0 };
        var expectedGradient = new[] { -5.10310363079829, -3.49428278907306, -2.3094010767585, -2.08333333333333, double.NegativeInfinity };
        input.To(device);

        // Act
        var result = input.ASech();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACoth(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { -0.549306144334055, double.NegativeInfinity, double.PositiveInfinity, 0.549306144334055, 0.346573590279973 };
        var expectedGradient = new[] { -0.333333333333333, double.NegativeInfinity, double.NegativeInfinity, -0.333333333333333, -0.125 };
        input.To(device);

        // Act
        var result = input.ACoth();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsch2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.231564820577194, 0.776819399895696, 0.776819399895696, 0.231564820577194, 0.107223600890403 };
        var expectedGradient = new[] { 0.215204470482002, 1.24645048028046, -1.24645048028046, -0.215204470482002, -0.0690325529942708 };
        input.To(device);

        // Act
        var result = input.ACsch2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASech2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0.2, 0.3, 0.5, 0.8, 1.0 }, requiresGradient: true);
        var expectedOutput = new[] { 5.25524295960705, 3.5112023013055, 1.73437810227264, 0.480453013918201, 0 };
        var expectedGradient = new[] { -23.3970327525893, -13.0953156465605, -6.08276797040757, -2.88811325233311, double.NaN };
        input.To(device);

        // Act
        var result = input.ASech2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACoth2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { -2.0, -1.0, 1.0, 2.0, 3.0 }, requiresGradient: true);
        var expectedOutput = new[] { 0.301737240203146, double.PositiveInfinity, double.PositiveInfinity, 0.301737240203146, 0.12011325347955 };
        var expectedGradient = new[] { 0.366204096222703, double.PositiveInfinity, double.NegativeInfinity, -0.366204096222703, -0.0866433975699932 };
        input.To(device);

        // Act
        var result = input.ACoth2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

}

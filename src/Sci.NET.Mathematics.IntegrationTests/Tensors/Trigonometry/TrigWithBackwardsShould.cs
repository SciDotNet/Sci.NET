// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.
// <auto-generated />

using System.Numerics;
using Sci.NET.Common.Numerics;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Mathematics.Tensors;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Trigonometry;

public class TrigWithBackwardsShould : IntegrationTestBase
{
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSin(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.841470984807897, 1, 0, -1, 0 };
        var expectedGradient = new[] { 1, 0.54030230586814, 0, -1, 0, 1 };
        input.To(device);

        // Act
        var result = input.Sin();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCos(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 0.54030230586814, 0, -1, 0, 1 };
        var expectedGradient = new[] { 0, -0.841470984807897, -1, 0, 1, 0 };
        input.To(device);

        // Act
        var result = input.Cos();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTan(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.5574077246549, double.NaN, 0, double.NaN, 0 };
        var expectedGradient = new[] { 1, 3.42551882081476, double.NaN, 1, double.NaN, 1 };
        input.To(device);

        // Act
        var result = input.Tan();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSin2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.708073418273571, 1, 0, 1, 0 };
        var expectedGradient = new[] { 0, 0.909297426825682, 0, 0, 0, 0 };
        input.To(device);

        // Act
        var result = input.Sin2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCos2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 0.291926581726429, 0, 1, 0, 1 };
        var expectedGradient = new[] { 0, -0.909297426825682, 0, 0, 0, 0 };
        input.To(device);

        // Act
        var result = input.Cos2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTan2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 2.42551882081476, double.NaN, 0, double.NaN, 0 };
        var expectedGradient = new[] { 0, 10.6698589449753, double.NaN, 0, double.NaN, 0 };
        input.To(device);

        // Act
        var result = input.Tan2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSinh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.1752011936438, 2.30129890230729, 11.5487393572577, 55.6543975994175, 267.744894041016 };
        var expectedGradient = new[] { 1, 1.54308063481524, 2.50917847865806, 11.5919532755215, 55.6633808904387, 267.746761483748 };
        input.To(device);

        // Act
        var result = input.Sinh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCosh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 1.54308063481524, 2.50917847865806, 11.5919532755215, 55.6633808904387, 267.746761483748 };
        var expectedGradient = new[] { 0, 1.1752011936438, 2.30129890230729, 11.5487393572577, 55.6543975994175, 267.744894041016 };
        input.To(device);

        // Act
        var result = input.Cosh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTanh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.761594155955765, 0.917152335667274, 0.99627207622075, 0.999838613988633, 0.999993025339611 };
        var expectedGradient = new[] { 1, 0.419974341614026, 0.158831593180063, 0.00744195014279621, 0.000322745977290033, 1.39492721328912E-05 };
        input.To(device);

        // Act
        var result = input.Tanh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSinh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.38109784554182, 5.29597663776076, 133.373380741874, 3097.41197215405, 71687.3282850352 };
        var expectedGradient = new[] { 0, 3.62686040784702, 11.5487393572577, 267.744894041016, 6195.82386360859, 143375.656566583 };
        input.To(device);

        // Act
        var result = input.Sinh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCosh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 2.38109784554182, 6.29597663776076, 134.373380741874, 3098.41197215405, 71688.3282850352 };
        var expectedGradient = new[] { 0, 3.62686040784702, 11.5487393572577, 267.744894041016, 6195.82386360859, 143375.656566583 };
        input.To(device);

        // Act
        var result = input.Cosh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForTanh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.580025658385974, 0.841168406819937, 0.992558049857204, 0.99967725402271, 0.999986050727867 };
        var expectedGradient = new[] { 0, 0.639700008449224, 0.291345533325699, 0.0148284142397898, 0.000645387781208148, 2.78983496829109E-05 };
        input.To(device);

        // Act
        var result = input.Tanh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASin(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 1.5707963267949, 1.5707963267949, 1.5707963267949, 1.5707963267949, 1.5707963267949 };
        var expectedGradient = new[] { 1, double.NaN, 0, 0, 0, 0 };
        input.To(device);

        // Act
        var result = input.ASin();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACos(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1.5707963267949, 0, 0, 0, 0, 0 };
        var expectedGradient = new[] { -1, double.NaN, 0, 0, 0, 0 };
        input.To(device);

        // Act
        var result = input.ACos();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATan(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.785398163397448, 1.00388482185389, 1.26262725567891, 1.36169168297116, 1.41296513650674 };
        var expectedGradient = new[] { 1, 0.5, 0.288400439142001, 0.0919996683503752, 0.0430911711880149, 0.0247045230318576 };
        input.To(device);

        // Act
        var result = input.ATan();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASin2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 2.46740110027234, 1.42040662741756, -0.814226335543573, -2.51392853764383, -3.90635886880375 };
        var expectedGradient = new[] { 0, double.NaN, -1.68938163989722, -1.21652911591502, -0.969319641182289, -0.813990330610181 };
        input.To(device);

        // Act
        var result = input.ASin2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACos2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 2.46740110027234, 0, -1.04699447285478, -3.28162743581591, -4.98132963791617, -6.37375996907609 };
        var expectedGradient = new[] { -3.14159265358979, double.NaN, -1.68938163989722, -1.21652911591502, -0.969319641182289, -0.813990330610181 };
        input.To(device);

        // Act
        var result = input.ACos2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATan2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.616850275068085, 1.00778473554861, 1.59422758678326, 1.85420423947284, 1.9964704769835 };
        var expectedGradient = new[] { 0, 0.785398163397448, 0.579041646941301, 0.232322577545209, 0.117353778832413, 0.0698132595160851 };
        input.To(device);

        // Act
        var result = input.ATan2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASinh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.881373587019543, 1.23340311751122, 1.86229574331085, 2.25441459299271, 2.53729750137336 };
        var expectedGradient = new[] { 1, 0.707106781186548, 0.537029272146315, 0.303314471053353, 0.207584130385766, 0.15717672547759 };
        input.To(device);

        // Act
        var result = input.ASinh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACosh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0, 1.02322747854755, 1.81152627246085, 2.23188925305808, 2.52463065993347 };
        var expectedGradient = new[] { 0, double.NaN, 0.825516161027683, 0.335774626735729, 0.217152271299785, 0.161209784767415 };
        input.To(device);

        // Act
        var result = input.ACosh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATanh(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, double.PositiveInfinity, 0.752469267141927, 0.329765314956699, 0.215480861058658, 0.160519557507885 };
        var expectedGradient = new[] { 1, double.NaN, -0.681476932117883, -0.112744599959518, -0.0471551089306556, -0.0259885947047562 };
        input.To(device);

        // Act
        var result = input.ATanh();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASinh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, 0.776819399895696, 1.52128325028639, 3.4681454355537, 5.08238515709851, 6.4378786104755 };
        var expectedGradient = new[] { 0, 1.24645048028046, 1.32474715692009, 1.12972249665448, 0.935961385630749, 0.797608225656671 };
        input.To(device);

        // Act
        var result = input.ASinh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACosh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { -2.46740110027234, 0, 1.04699447285478, 3.28162743581591, 4.98132963791617, 6.37375996907609 };
        var expectedGradient = new[] { 3.14159265358979, double.NaN, 1.68938163989722, 1.21652911591502, 0.969319641182289, 0.813990330610181 };
        input.To(device);

        // Act
        var result = input.ACosh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForATanh2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, double.PositiveInfinity, -1.90119110227923, -2.35865593732385, -2.42096909878976, -2.44163457192981 };
        var expectedGradient = new[] { 0, double.NaN, -1.02558089536974, -0.074358517030635, -0.020322046951385, -0.00834335544451847 };
        input.To(device);

        // Act
        var result = input.ATanh2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsc(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 1.18839510577812, 1, double.NaN, -1, double.NaN };
        var expectedGradient = new[] { double.NaN, -0.76305972223263, 0, double.NaN, 0, double.NaN };
        input.To(device);

        // Act
        var result = input.Csc();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSec(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 1.85081571768093, double.NaN, -1, double.NaN, 1 };
        var expectedGradient = new[] { 0, 2.88247469562898, double.NaN, 0, double.NaN, 0 };
        input.To(device);

        // Act
        var result = input.Sec();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCot(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.642092615934331, 0, double.NaN, 0, double.NaN };
        var expectedGradient = new[] { double.NaN, -1.41228292743739, -1, double.NaN, -1, double.NaN };
        input.To(device);

        // Act
        var result = input.Cot();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsc2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 1.41228292743739, 1, double.NaN, 1, double.NaN };
        var expectedGradient = new[] { double.NaN, -1.81363287863534, 0, double.NaN, 0, double.NaN };
        input.To(device);

        // Act
        var result = input.Csc2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSec2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 3.42551882081476, double.NaN, 1, double.NaN, 1 };
        var expectedGradient = new[] { 0, 10.6698589449753, double.NaN, 0, double.NaN, 0 };
        input.To(device);

        // Act
        var result = input.Sec2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCot2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.412282927437392, 0, double.NaN, 0, double.NaN };
        var expectedGradient = new[] { double.NaN, -1.81363287863534, 0, double.NaN, 0, double.NaN };
        input.To(device);

        // Act
        var result = input.Cot2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsch(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.850918128239322, 0.434537208094696, 0.0865895375300469, 0.0179680320537773, 0.00373489848828567 };
        var expectedGradient = new[] { double.NaN, -1.11728552744927, -0.473789567115422, -0.0869135445996991, -0.0179709323108635, -0.00373492453811591 };
        input.To(device);

        // Act
        var result = input.Csch();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSech(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 0.648054273663885, 0.398536815338387, 0.0862667383340544, 0.017965132264752, 0.00373487243863713 };
        var expectedGradient = new[] { 0, -0.493554347564573, -0.365518971036999, -0.0859451425088606, -0.0179622329437121, -0.00373484638917027 };
        input.To(device);

        // Act
        var result = input.Sech();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCoth(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 1.31303528549933, 1.09033141072737, 1.00374187319732, 1.00016141206102, 1.00000697470904 };
        var expectedGradient = new[] { double.NaN, -0.72406166096631, -0.188822585218733, -0.00749774800966741, -0.000322850175885568, -1.39494667177986E-05 };
        input.To(device);

        // Act
        var result = input.Coth();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCsch2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.72406166096631, 0.188822585218733, 0.00749774800966741, 0.000322850175885568, 1.39494667177986E-05 };
        var expectedGradient = new[] { double.NaN, -1.90143701945204, -0.41175839143746, -0.0150516072639701, -0.000645804575595714, -2.78991280225403E-05 };
        input.To(device);

        // Act
        var result = input.Csch2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForSech2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1, 0.419974341614026, 0.158831593180063, 0.00744195014279621, 0.000322745977290033, 1.39492721328912E-05 };
        var expectedGradient = new[] { 0, -0.639700008449224, -0.291345533325699, -0.0148284142397898, -0.000645387781208148, -2.78983496829109E-05 };
        input.To(device);

        // Act
        var result = input.Sech2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForCoth2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 1.72406166096631, 1.18882258521873, 1.00749774800967, 1.00032285017589, 1.00001394946672 };
        var expectedGradient = new[] { double.NaN, -1.90143701945204, -0.41175839143746, -0.0150516072639701, -0.000645804575595714, -2.78991280225403E-05 };
        input.To(device);

        // Act
        var result = input.Coth2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsc(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 1.5707963267949, 0.69010709137454, 0.323946106931981, 0.213832425883772, 0.159834626385137 };
        var expectedGradient = new[] { double.NaN, double.NaN, -0.525539910519203, -0.106880383219655, -0.0460811431746576, -0.0256573341205146 };
        input.To(device);

        // Act
        var result = input.ACsc();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASec(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0, 0.880689235420357, 1.24685021986292, 1.35696390091112, 1.41096170040976 };
        var expectedGradient = new[] { double.NaN, double.NaN, 0.525539910519203, 0.106880383219655, 0.0460811431746576, 0.0256573341205146 };
        input.To(device);

        // Act
        var result = input.ASec();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACot(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 1.5707963267949, 0.785398163397448, 0.566911504941009, 0.308169071115985, 0.209104643823733, 0.157831190288159 };
        var expectedGradient = new[] { -1, -0.5, -0.288400439142001, -0.0919996683503752, -0.0430911711880149, -0.0247045230318576 };
        input.To(device);

        // Act
        var result = input.ACot();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsc2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 2.46740110027234, 0.476247797565428, 0.104941080196386, 0.045724306359339, 0.0255471077916763 };
        var expectedGradient = new[] { double.NaN, double.NaN, -0.725357638099286, -0.0692469681028106, -0.0197072852650689, -0.00820186082638215 };
        input.To(device);

        // Act
        var result = input.ACsc2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASec2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0, 0.775613529385292, 1.5546354707722, 1.84135102837594, 1.9908129200232 };
        var expectedGradient = new[] { double.NaN, double.NaN, 0.925674683956079, 0.266527658632918, 0.125060895601455, 0.0724030315573252 };
        input.To(device);

        // Act
        var result = input.ASec2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACot2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 2.46740110027234, 0.616850275068085, 0.32138865443448, 0.094968176392489, 0.0437247520686503, 0.024910684627777 };
        var expectedGradient = new[] { -3.14159265358979, -0.785398163397448, -0.32699505395928, -0.0567029046770276, -0.0180211280064347, -0.00779828855123865 };
        input.To(device);

        // Act
        var result = input.ACot2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsch(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.881373587019543, 0.599971479517857, 0.313165880450868, 0.210645357198105, 0.158490581423507 };
        var expectedGradient = new[] { double.NaN, -0.707106781186548, -0.341883452988515, -0.0965479947588894, -0.044050720611103, -0.0250154527987563 };
        input.To(device);

        // Act
        var result = input.ACsch();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASech(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.PositiveInfinity, 0, 0, 0, 0, 0 };
        var expectedGradient = new[] { double.NaN, double.NaN, 0, 0, 0, 0 };
        input.To(device);

        // Act
        var result = input.ASech();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACoth(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { 0, double.PositiveInfinity, 0.752469267141927, 0.329765314956699, 0.215480861058658, 0.160519557507885 };
        var expectedGradient = new[] { 1, double.NaN, -0.681476932117883, -0.112744599959518, -0.0471551089306556, -0.0259885947047562 };
        input.To(device);

        // Act
        var result = input.ACoth();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACsch2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.NaN, 0.776819399895696, 0.359965776234846, 0.0980728686785676, 0.0443714665091173, 0.0251192643999613 };
        var expectedGradient = new[] { double.NaN, -1.24645048028046, -0.410240642224386, -0.0604710755688669, -0.0185581595559194, -0.00792942731729435 };
        input.To(device);

        // Act
        var result = input.ACsch2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForASech2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { double.PositiveInfinity, 0, -0.775613529385292, -1.5546354707722, -1.84135102837594, -1.9908129200232 };
        var expectedGradient = new[] { double.NaN, double.NaN, -0.925674683956079, -0.266527658632918, -0.125060895601455, -0.0724030315573252 };
        input.To(device);

        // Act
        var result = input.ASech2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_ForACoth2(IDevice device)
    {
        // Arrange
        using var input = Tensor.FromArray<double>(new[] { 0, 1, double.Pi / 2, double.Pi, 1.5 * double.Pi, 2 * double.Pi }, requiresGradient: true);
        var expectedOutput = new[] { -2.46740110027234, double.PositiveInfinity, 0.566209997993109, 0.108745162948491, 0.0464320014825807, 0.0257665283425273 };
        var expectedGradient = new[] { 0, double.NaN, -1.02558089536974, -0.074358517030635, -0.020322046951385, -0.00834335544451847 };
        input.To(device);

        // Act
        var result = input.ACoth2();
        
        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedOutput, 1e-5);
        input.Gradient!.Should().HaveApproximatelyEquivalentElements(expectedGradient, 1e-5);
    }

}
